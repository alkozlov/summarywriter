# Chapter 5: Pods and Namespaces

## Overview
The Pod is the most important primitive in the Kubernetes API. It allows you to run containerized applications. Typically, there is a one-to-one mapping between a Pod and a container, but multiple containers can be declared in a single Pod for specific use cases.

## Working with Pods
### Creating Pods
You can create a Pod using either imperative or declarative methods. The Pod definition must specify an image for each container. If the image is not present on the node, it will be downloaded from a container image registry (default is Docker Hub).

### Imperative Command Example
To run a Hazelcast instance inside a Pod:
```shell
$ kubectl run hazelcast --image=hazelcast/hazelcast:5.1.7 \
  --port=5701 --env="DNS_DOMAIN=cluster" --labels="app=hazelcast,env=prod"
```

### Important kubectl run Options
| Option      | Example Value         | Description                                          |
|-------------|-----------------------|------------------------------------------------------|
| --image     | nginx:1.25.1          | The image for the container to run.                  |
| --port      | 8080                  | The port that this container exposes.                 |
| --env       | PROFILE=dev           | The environment variables to set in the container.   |
| --labels    | app=frontend          | A comma-separated list of labels to apply to the Pod.|

### Declarative Command Example
You can also create a Pod from a YAML manifest:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hazelcast
  labels:
    app: hazelcast
    env: prod
spec:
  containers:
  - name: hazelcast
    image: hazelcast/hazelcast:5.1.7
    env:
    - name: DNS_DOMAIN
      value: cluster
    ports:
    - containerPort: 5701
```
To create the Pod from the manifest:
```shell
$ kubectl apply -f pod.yaml
```

### Listing Pods
To list all Pods in the cluster:
```shell
$ kubectl get pods
```

### Pod Life Cycle Phases
Pods go through several life cycle phases:
- **Pending**: The Pod has been accepted, but not all container images have been created.
- **Running**: At least one container is running.
- **Succeeded**: All containers terminated successfully.
- **Failed**: At least one container failed.
- **Unknown**: The state of the Pod could not be obtained.

### Accessing Logs
To access logs from a Pod:
```shell
$ kubectl logs hazelcast
```

### Executing Commands in a Container
To open a shell in a running container:
```shell
$ kubectl exec -it hazelcast -- /bin/sh
```

### Creating a Temporary Pod
To create a temporary Pod that deletes itself after execution:
```shell
$ kubectl run busybox --image=busybox:1.36.1 --rm -it --restart=Never -- env
```

## Working with Namespaces
Namespaces help avoid naming collisions and represent a scope for object names.

### Listing Namespaces
To list all namespaces:
```shell
$ kubectl get namespaces
```

### Creating a Namespace
To create a new namespace:
```shell
$ kubectl create namespace code-red
```

### Setting a Namespace Preference
To set a permanent namespace preference:
```shell
$ kubectl config set-context --current --namespace=code-red
```

### Deleting a Namespace
To delete a namespace and all its objects:
```shell
$ kubectl delete namespace code-red
```

## Summary
The chapter emphasizes the significance of Pods in Kubernetes, their creation, management, and the role of namespaces in organizing resources.